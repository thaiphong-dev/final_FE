{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import AnimatedNode from\"./AnimatedNode\";import deepEqual from'fbjs/lib/areEqual';function sanitizeTransform(inputTransform){var outputTransform=[];inputTransform.forEach(function(transform){for(var key in transform){var value=transform[key];if(value instanceof AnimatedNode){outputTransform.push({property:key,nodeID:value.__nodeID});}else{outputTransform.push({property:key,value:value});}}});return outputTransform;}function extractAnimatedParentNodes(transform){var parents=[];transform.forEach(function(transform){for(var key in transform){var value=transform[key];if(value instanceof AnimatedNode){parents.push(value);}}});return parents;}export function createOrReuseTransformNode(transform,oldNode){var config=sanitizeTransform(transform);if(oldNode&&deepEqual(config,oldNode._config)){return oldNode;}return new AnimatedTransform(transform,config);}var AnimatedTransform=function(_AnimatedNode){_inherits(AnimatedTransform,_AnimatedNode);var _super=_createSuper(AnimatedTransform);function AnimatedTransform(transform,config){var _this;_classCallCheck(this,AnimatedTransform);_this=_super.call(this,{type:'transform',transform:config},extractAnimatedParentNodes(transform));_this._config=config;_this._transform=transform;return _this;}_createClass(AnimatedTransform,[{key:\"toString\",value:function toString(){return\"AnimatedTransform, id: \".concat(this.__nodeID);}},{key:\"__onEvaluate\",value:function __onEvaluate(){return this._transform.map(function(transform){var result={};for(var key in transform){var value=transform[key];if(value instanceof AnimatedNode){result[key]=value.__getValue();}}return result;});}}]);return AnimatedTransform;}(AnimatedNode);","map":{"version":3,"sources":["AnimatedTransform.js"],"names":["outputTransform","inputTransform","transform","value","property","nodeID","__nodeID","parents","config","sanitizeTransform","oldNode","deepEqual","constructor","type","extractAnimatedParentNodes","toString","__onEvaluate","result"],"mappings":"qgCAAA,MAAA,CAAA,YAAA,sBAEA,MAAA,CAAA,SAAA,KAAA,mBAAA,CAEA,QAAA,CAAA,iBAAA,CAAA,cAAA,CAA2C,CACzC,GAAMA,CAAAA,eAAe,CAArB,EAAA,CACAC,cAAc,CAAdA,OAAAA,CAAuBC,SAAAA,SAAS,CAAI,CAClC,IAAK,GAAL,CAAA,GAAA,GAAA,CAAA,SAAA,CAA6B,CAC3B,GAAMC,CAAAA,KAAK,CAAGD,SAAS,CAAvB,GAAuB,CAAvB,CACA,GAAIC,KAAK,WAAT,CAAA,YAAA,CAAmC,CACjCH,eAAe,CAAfA,IAAAA,CAAqB,CACnBI,QAAQ,CADW,GAAA,CAEnBC,MAAM,CAAEF,KAAK,CAACG,QAFK,CAArBN,EADF,CAAA,IAKO,CACLA,eAAe,CAAfA,IAAAA,CAAqB,CACnBI,QAAQ,CADW,GAAA,CAEnBD,KAAAA,CAAAA,KAFmB,CAArBH,EAID,CACF,CAdHC,CAAAA,EAgBA,MAAA,CAAA,eAAA,CACD,CAED,QAAA,CAAA,0BAAA,CAAA,SAAA,CAA+C,CAC7C,GAAMM,CAAAA,OAAO,CAAb,EAAA,CACAL,SAAS,CAATA,OAAAA,CAAkBA,SAAAA,SAAS,CAAI,CAC7B,IAAK,GAAL,CAAA,GAAA,GAAA,CAAA,SAAA,CAA6B,CAC3B,GAAMC,CAAAA,KAAK,CAAGD,SAAS,CAAvB,GAAuB,CAAvB,CACA,GAAIC,KAAK,WAAT,CAAA,YAAA,CAAmC,CACjCI,OAAO,CAAPA,IAAAA,CAAAA,KAAAA,EACD,CACF,CANHL,CAAAA,EAQA,MAAA,CAAA,OAAA,CACD,CAED,MAAO,SAAA,CAAA,0BAAA,CAAA,SAAA,CAAA,OAAA,CAAwD,CAC7D,GAAMM,CAAAA,MAAM,CAAGC,iBAAiB,CAAhC,SAAgC,CAAhC,CACA,GAAIC,OAAO,EAAIC,SAAS,CAAA,MAAA,CAASD,OAAO,CAAxC,OAAwB,CAAxB,CAAmD,CACjD,MAAA,CAAA,OAAA,CACD,CACD,MAAO,IAAA,CAAA,iBAAA,CAAA,SAAA,CAAP,MAAO,CAAP,CACD,C,GAED,CAAA,iB,+GACEE,2BAAW,SAAXA,CAAW,MAAXA,CAA+B,mDAC7B,uBACE,CAAEC,IAAI,CAAN,WAAA,CAAqBX,SAAS,CAAEM,MAAhC,CADF,CAEEM,0BAA0B,CAF5B,SAE4B,CAF5B,EAIA,MAAA,OAAA,CAAA,MAAA,CACA,MAAA,UAAA,CAAA,SAAA,CAN6B,aAO9B,C,sDAEDC,mBAAW,CACT,MAAA,0BAAA,MAAA,CAAiC,KAAjC,QAAA,CAAA,CACD,C,4BAEDC,uBAAe,CACb,MAAO,MAAA,UAAA,CAAA,GAAA,CAAoBd,SAAAA,SAAS,CAAI,CACtC,GAAMe,CAAAA,MAAM,CAAZ,EAAA,CACA,IAAK,GAAL,CAAA,GAAA,GAAA,CAAA,SAAA,CAA6B,CAC3B,GAAMd,CAAAA,KAAK,CAAGD,SAAS,CAAvB,GAAuB,CAAvB,CACA,GAAIC,KAAK,WAAT,CAAA,YAAA,CAAmC,CACjCc,MAAM,CAANA,GAAM,CAANA,CAAcd,KAAK,CAAnBc,UAAcd,EAAdc,CACD,CACF,CACD,MAAA,CAAA,MAAA,CARF,CAAO,CAAP,CAUD,C,+BAzBH,Y","sourcesContent":["import AnimatedNode from './AnimatedNode';\n\nimport deepEqual from 'fbjs/lib/areEqual';\n\nfunction sanitizeTransform(inputTransform) {\n  const outputTransform = [];\n  inputTransform.forEach(transform => {\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        outputTransform.push({\n          property: key,\n          nodeID: value.__nodeID,\n        });\n      } else {\n        outputTransform.push({\n          property: key,\n          value,\n        });\n      }\n    }\n  });\n  return outputTransform;\n}\n\nfunction extractAnimatedParentNodes(transform) {\n  const parents = [];\n  transform.forEach(transform => {\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        parents.push(value);\n      }\n    }\n  });\n  return parents;\n}\n\nexport function createOrReuseTransformNode(transform, oldNode) {\n  const config = sanitizeTransform(transform);\n  if (oldNode && deepEqual(config, oldNode._config)) {\n    return oldNode;\n  }\n  return new AnimatedTransform(transform, config);\n}\n\nclass AnimatedTransform extends AnimatedNode {\n  constructor(transform, config) {\n    super(\n      { type: 'transform', transform: config },\n      extractAnimatedParentNodes(transform)\n    );\n    this._config = config;\n    this._transform = transform;\n  }\n\n  toString() {\n    return `AnimatedTransform, id: ${this.__nodeID}`;\n  }\n\n  __onEvaluate() {\n    return this._transform.map(transform => {\n      const result = {};\n      for (const key in transform) {\n        const value = transform[key];\n        if (value instanceof AnimatedNode) {\n          result[key] = value.__getValue();\n        }\n      }\n      return result;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}