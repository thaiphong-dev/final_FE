{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _assertThisInitialized from\"@babel/runtime/helpers/assertThisInitialized\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import React from'react';import findNodeHandle from\"react-native-web/dist/exports/findNodeHandle\";import Platform from\"react-native-web/dist/exports/Platform\";import StyleSheet from\"react-native-web/dist/exports/StyleSheet\";import ReanimatedEventEmitter from\"./ReanimatedEventEmitter\";import AnimatedEvent from\"./core/AnimatedEvent\";import AnimatedNode from\"./core/AnimatedNode\";import AnimatedValue from\"./core/AnimatedValue\";import{createOrReusePropsNode}from\"./core/AnimatedProps\";import invariant from'fbjs/lib/invariant';var NODE_MAPPING=new Map();function listener(data){var component=NODE_MAPPING.get(data.viewTag);component&&component._updateFromNative(data.props);}function dummyListener(){}export default function createAnimatedComponent(Component){invariant(typeof Component!=='function'||Component.prototype&&Component.prototype.isReactComponent,'`createAnimatedComponent` does not support stateless functional components; '+'use a class component instead.');var AnimatedComponent=function(_React$Component){_inherits(AnimatedComponent,_React$Component);var _super=_createSuper(AnimatedComponent);function AnimatedComponent(props){var _this;_classCallCheck(this,AnimatedComponent);_this=_super.call(this,props);_defineProperty(_assertThisInitialized(_this),\"_invokeAnimatedPropsCallbackOnMount\",false);_defineProperty(_assertThisInitialized(_this),\"_animatedPropsCallback\",function(){if(_this._component==null){_this._invokeAnimatedPropsCallbackOnMount=true;}else if(typeof _this._component.setNativeProps!=='function'){_this.forceUpdate();}else{_this._component.setNativeProps(_this._propsAnimated.__getValue());}});_defineProperty(_assertThisInitialized(_this),\"_setComponentRef\",function(c){if(c!==_this._component){_this._component=c;}});_this._attachProps(_this.props);return _this;}_createClass(AnimatedComponent,[{key:\"componentWillUnmount\",value:function componentWillUnmount(){this._detachPropUpdater();this._propsAnimated&&this._propsAnimated.__detach();this._detachNativeEvents();}},{key:\"setNativeProps\",value:function setNativeProps(props){this._component.setNativeProps(props);}},{key:\"componentDidMount\",value:function componentDidMount(){if(this._invokeAnimatedPropsCallbackOnMount){this._invokeAnimatedPropsCallbackOnMount=false;this._animatedPropsCallback();}this._propsAnimated.setNativeView(this._component);this._attachNativeEvents();this._attachPropUpdater();}},{key:\"_getEventViewRef\",value:function _getEventViewRef(){return this._component.getScrollableNode?this._component.getScrollableNode():this._component;}},{key:\"_attachNativeEvents\",value:function _attachNativeEvents(){var node=this._getEventViewRef();for(var key in this.props){var prop=this.props[key];if(prop instanceof AnimatedEvent){prop.attachEvent(node,key);}}}},{key:\"_detachNativeEvents\",value:function _detachNativeEvents(){var node=this._getEventViewRef();for(var key in this.props){var prop=this.props[key];if(prop instanceof AnimatedEvent){prop.detachEvent(node,key);}}}},{key:\"_reattachNativeEvents\",value:function _reattachNativeEvents(prevProps){var node=this._getEventViewRef();var attached=new Set();var nextEvts=new Set();for(var key in this.props){var prop=this.props[key];if(prop instanceof AnimatedEvent){nextEvts.add(prop.__nodeID);}}for(var _key in prevProps){var _prop=this.props[_key];if(_prop instanceof AnimatedEvent){if(!nextEvts.has(_prop.__nodeID)){_prop.detachEvent(node,_key);}else{attached.add(_prop.__nodeID);}}}for(var _key2 in this.props){var _prop2=this.props[_key2];if(_prop2 instanceof AnimatedEvent&&!attached.has(_prop2.__nodeID)){_prop2.attachEvent(node,_key2);}}}},{key:\"_attachProps\",value:function _attachProps(nextProps){var oldPropsAnimated=this._propsAnimated;this._propsAnimated=createOrReusePropsNode(nextProps,this._animatedPropsCallback,oldPropsAnimated);if(oldPropsAnimated!==this._propsAnimated){oldPropsAnimated&&oldPropsAnimated.__detach();}}},{key:\"_updateFromNative\",value:function _updateFromNative(props){this._component.setNativeProps(props);}},{key:\"_attachPropUpdater\",value:function _attachPropUpdater(){var viewTag=findNodeHandle(this);NODE_MAPPING.set(viewTag,this);if(NODE_MAPPING.size===1){ReanimatedEventEmitter.addListener('onReanimatedPropsChange',listener);}}},{key:\"_detachPropUpdater\",value:function _detachPropUpdater(){var viewTag=findNodeHandle(this);NODE_MAPPING.delete(viewTag);if(NODE_MAPPING.size===0){ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');}}},{key:\"componentDidUpdate\",value:function componentDidUpdate(prevProps){this._attachProps(this.props);this._reattachNativeEvents(prevProps);this._propsAnimated.setNativeView(this._component);}},{key:\"_filterNonAnimatedStyle\",value:function _filterNonAnimatedStyle(inputStyle){var style={};for(var key in inputStyle){var value=inputStyle[key];if(key!=='transform'){if(value instanceof AnimatedValue){style[key]=value._startingValue;}else if(!(value instanceof AnimatedNode)){style[key]=value;}}}return style;}},{key:\"_filterNonAnimatedProps\",value:function _filterNonAnimatedProps(inputProps){var props={};for(var key in inputProps){var value=inputProps[key];if(key==='style'){props[key]=this._filterNonAnimatedStyle(StyleSheet.flatten(value));}else if(value instanceof AnimatedEvent){props[key]=dummyListener;}else if(value instanceof AnimatedValue){props[key]=value._startingValue;}else if(!(value instanceof AnimatedNode)){props[key]=value;}}return props;}},{key:\"render\",value:function render(){var props=this._filterNonAnimatedProps(this.props);var platformProps=Platform.select({web:{},default:{collapsable:false}});return React.createElement(Component,_extends({},props,{ref:this._setComponentRef},platformProps));}},{key:\"getNode\",value:function getNode(){return this._component;}}]);return AnimatedComponent;}(React.Component);AnimatedComponent.displayName=\"AnimatedComponent(\".concat(Component.displayName||Component.name||'Component',\")\");return AnimatedComponent;}","map":{"version":3,"sources":["createAnimatedComponent.js"],"names":["NODE_MAPPING","component","data","invariant","Component","React","constructor","componentWillUnmount","setNativeProps","componentDidMount","_getEventViewRef","_attachNativeEvents","node","prop","_detachNativeEvents","_reattachNativeEvents","attached","nextEvts","_attachProps","oldPropsAnimated","createOrReusePropsNode","_updateFromNative","_attachPropUpdater","viewTag","findNodeHandle","ReanimatedEventEmitter","_detachPropUpdater","componentDidUpdate","c","_filterNonAnimatedStyle","style","value","inputStyle","key","_filterNonAnimatedProps","props","inputProps","StyleSheet","render","platformProps","web","default","collapsable","_setComponentRef","getNode","AnimatedComponent"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport AnimatedValue from './core/AnimatedValue';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        }\n      }\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = c => {\n      if (c !== this._component) {\n        this._component = c;\n      }\n    };\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (key !== 'transform') {\n          if (value instanceof AnimatedValue) {\n            style[key] = value._startingValue;\n          } else if (!(value instanceof AnimatedNode)) {\n            style[key] = value;\n          }\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (value instanceof AnimatedValue) {\n          props[key] = value._startingValue;\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n\n    // A third party library can use getNode()\n    // to get the node reference of the decorated component\n    getNode() {\n      return this._component;\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName ||\n    Component.name ||\n    'Component'})`;\n\n  return AnimatedComponent;\n}\n"]},"metadata":{},"sourceType":"module"}