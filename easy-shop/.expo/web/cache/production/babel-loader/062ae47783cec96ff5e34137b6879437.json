{"ast":null,"code":"import AnimatedValue from\"../core/InternalAnimatedValue\";import{createAnimatedSet as set}from\"../core/AnimatedSet\";import{createAnimatedCall as call}from\"../core/AnimatedCall\";import{createAnimatedAlways as always}from\"../core/AnimatedAlways\";import{createAnimatedCond as cond}from\"../core/AnimatedCond\";export function evaluateOnce(node){var input=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var callback=arguments.length>2?arguments[2]:undefined;if(!Array.isArray(input)){input=[input];}var done=new AnimatedValue(0);var evalNode=cond(done,0,call([node,set(done,1)],function(){callback&&callback();for(var i=0;i<input.length;i++){input[i].__removeChild(alwaysNode);alwaysNode.__detach();}}));var alwaysNode=always(evalNode);for(var i=0;i<input.length;i++){input[i].__addChild(alwaysNode);alwaysNode.__attach();}}","map":{"version":3,"sources":["evaluateOnce.js"],"names":["createAnimatedSet","createAnimatedCall","createAnimatedAlways","createAnimatedCond","input","Array","done","evalNode","cond","call","set","callback","i","alwaysNode","always"],"mappings":"AAAA,MAAA,CAAA,aAAA,qCACA,OAASA,iBAAiB,GAA1B,CAAA,GAAA,2BACA,OAASC,kBAAkB,GAA3B,CAAA,IAAA,4BACA,OAASC,oBAAoB,GAA7B,CAAA,MAAA,8BACA,OAASC,kBAAkB,GAA3B,CAAA,IAAA,4BASA,MAAO,SAAA,CAAA,YAAA,CAAA,IAAA,CAAkD,IAAtBC,CAAAA,KAAsB,2DAAlD,EAAkD,IAAlD,CAAA,QAAkD,2CACvD,GAAI,CAACC,KAAK,CAALA,OAAAA,CAAL,KAAKA,CAAL,CAA2B,CACzBD,KAAK,CAAG,CAARA,KAAQ,CAARA,CACD,CACD,GAAME,CAAAA,IAAI,CAAG,GAAA,CAAA,aAAA,CAAb,CAAa,CAAb,CACA,GAAMC,CAAAA,QAAQ,CAAGC,IAAI,CAAA,IAAA,CAAA,CAAA,CAGnBC,IAAI,CAAC,CAAA,IAAA,CAAOC,GAAG,CAAA,IAAA,CAAX,CAAW,CAAV,CAAD,CAAuB,UAAM,CAC/BC,QAAQ,EAAIA,QAAZA,EAAAA,CACA,IAAK,GAAIC,CAAAA,CAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGR,KAAK,CAAzB,MAAA,CAAkCQ,CAAlC,EAAA,CAAuC,CACrCR,KAAK,CAALA,CAAK,CAALA,CAAAA,aAAAA,CAAAA,UAAAA,EACAS,UAAU,CAAVA,QAAAA,GACD,CARL,CAGM,CAHe,CAArB,CAWA,GAAMA,CAAAA,UAAU,CAAGC,MAAM,CAAzB,QAAyB,CAAzB,CACA,IAAK,GAAIF,CAAAA,CAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGR,KAAK,CAAzB,MAAA,CAAkCQ,CAAlC,EAAA,CAAuC,CACrCR,KAAK,CAALA,CAAK,CAALA,CAAAA,UAAAA,CAAAA,UAAAA,EACAS,UAAU,CAAVA,QAAAA,GACD,CACF","sourcesContent":["import AnimatedValue from '../core/InternalAnimatedValue';\nimport { createAnimatedSet as set } from '../core/AnimatedSet';\nimport { createAnimatedCall as call } from '../core/AnimatedCall';\nimport { createAnimatedAlways as always } from '../core/AnimatedAlways';\nimport { createAnimatedCond as cond } from '../core/AnimatedCond';\n\n/**\n * evaluate given node and notify children\n * @param node - node to be evaluated\n * @param input - nodes (or one node) representing values which states input for node.\n * @param callback - after callback\n */\n\nexport function evaluateOnce(node, input = [], callback) {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  const done = new AnimatedValue(0);\n  const evalNode = cond(\n    done,\n    0,\n    call([node, set(done, 1)], () => {\n      callback && callback();\n      for (let i = 0; i < input.length; i++) {\n        input[i].__removeChild(alwaysNode);\n        alwaysNode.__detach();\n      }\n    })\n  );\n  const alwaysNode = always(evalNode);\n  for (let i = 0; i < input.length; i++) {\n    input[i].__addChild(alwaysNode);\n    alwaysNode.__attach();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}