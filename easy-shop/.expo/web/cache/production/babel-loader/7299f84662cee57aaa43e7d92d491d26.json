{"ast":null,"code":"import{always,block,call,clockRunning,cond,set,startClock,stopClock}from\"../base\";import Clock from\"../core/AnimatedClock\";import{evaluateOnce}from\"../derived/evaluateOnce\";function createOldAnimationObject(node,animationStateDefaults,value,config){var newClock=new Clock();var currentState=animationStateDefaults();var alwaysNode;var isStarted=false;var isDone=false;var wasStopped=false;var animationCallback;var animation={start:function start(currentAnimationCallback){animationCallback=currentAnimationCallback;if(isStarted){animationCallback&&animationCallback({finished:false});return;}if(isDone){console.warn('Animation has been finished before');return;}if(!value.isNativelyInitialized()){return;}isStarted=true;evaluateOnce(set(currentState.position,value),currentState.position,function(){alwaysNode=always(set(value,block([cond(clockRunning(newClock),0,startClock(newClock)),node(newClock,currentState,config),cond(currentState.finished,[call([],function(){isStarted=false;if(!wasStopped){isDone=true;}value.__detachAnimation(animation);isDone=true;if(!wasStopped){wasStopped=false;}}),stopClock(newClock)]),currentState.position])));value.__attachAnimation(animation);alwaysNode.__addChild(value);});},__detach:function __detach(){animationCallback&&animationCallback({finished:isDone});animationCallback=null;value.__initialized&&alwaysNode.__removeChild(value);},stop:function stop(){if(isDone){console.warn('Calling stop has no effect as the animation has already completed');return;}if(!isStarted){console.warn(\"Calling stop has no effect as the animation hasn't been started\");return;}wasStopped=true;evaluateOnce(set(currentState.finished,1),currentState.finished);},__stopImmediately_testOnly:function __stopImmediately_testOnly(result){animation.stop();isDone=result;value.__detachAnimation(animation);}};return animation;}export default function backwardsCompatibleAnimWrapper(node,animationStateDefaults){return function(clock,state,config){if(config!==undefined){return node(clock,state,config);}return createOldAnimationObject(node,animationStateDefaults,clock,state);};}","map":{"version":3,"sources":["backwardCompatibleAnimWrapper.js"],"names":["newClock","currentState","animationStateDefaults","isStarted","isDone","wasStopped","animation","start","currentAnimationCallback","animationCallback","finished","console","value","evaluateOnce","set","alwaysNode","always","block","cond","clockRunning","startClock","node","call","stopClock","__detach","stop","__stopImmediately_testOnly","result","config","createOldAnimationObject"],"mappings":"AAAA,OAAA,MAAA,CAAA,KAAA,CAAA,IAAA,CAAA,YAAA,CAAA,IAAA,CAAA,GAAA,CAAA,UAAA,CAAA,SAAA,eAUA,MAAA,CAAA,KAAA,6BACA,OAAA,YAAA,+BAEA,QAAA,CAAA,wBAAA,CAAA,IAAA,CAAA,sBAAA,CAAA,KAAA,CAAA,MAAA,CAA+E,CAC7E,GAAMA,CAAAA,QAAQ,CAAG,GAAjB,CAAA,KAAiB,EAAjB,CACA,GAAMC,CAAAA,YAAY,CAAGC,sBAArB,EAAA,CACA,GAAA,CAAA,UAAA,CACA,GAAIC,CAAAA,SAAS,CAAb,KAAA,CACA,GAAIC,CAAAA,MAAM,CAAV,KAAA,CACA,GAAIC,CAAAA,UAAU,CAAd,KAAA,CACA,GAAA,CAAA,iBAAA,CACA,GAAMC,CAAAA,SAAS,CAAG,CAChBC,KAAK,CAAEC,eAAAA,wBAAwB,CAAI,CACjCC,iBAAiB,CAAjBA,wBAAAA,CACA,GAAA,SAAA,CAAe,CACbA,iBAAiB,EAAIA,iBAAiB,CAAC,CAAEC,QAAQ,CAAE,KAAZ,CAAD,CAAtCD,CACA,OACD,CACD,GAAA,MAAA,CAAY,CACVE,OAAO,CAAPA,IAAAA,CADU,oCACVA,EAEA,OACD,CAED,GAAI,CAACC,KAAK,CAAV,qBAAKA,EAAL,CAAoC,CAClC,OACD,CAEDT,SAAS,CAATA,IAAAA,CACAU,YAAY,CACVC,GAAG,CAACb,YAAY,CAAb,QAAA,CADO,KACP,CADO,CAEVA,YAAY,CAFF,QAAA,CAGV,UAAM,CACJc,UAAU,CAAGC,MAAM,CACjBF,GAAG,CAAA,KAAA,CAEDG,KAAK,CAAC,CACJC,IAAI,CAACC,YAAY,CAAb,QAAa,CAAb,CAAA,CAAA,CAA4BC,UAAU,CADtC,QACsC,CAAtC,CADA,CAEJC,IAAI,CAAA,QAAA,CAAA,YAAA,CAFA,MAEA,CAFA,CAGJH,IAAI,CAACjB,YAAY,CAAb,QAAA,CAAwB,CAC1BqB,IAAI,CAAA,EAAA,CAAK,UAAM,CACbnB,SAAS,CAATA,KAAAA,CACA,GAAI,CAAJ,UAAA,CAAiB,CACfC,MAAM,CAANA,IAAAA,CACD,CACDQ,KAAK,CAALA,iBAAAA,CAAAA,SAAAA,EACAR,MAAM,CAANA,IAAAA,CACA,GAAI,CAAJ,UAAA,CAAiB,CACfC,UAAU,CAAVA,KAAAA,CACD,CAVuB,CACtB,CADsB,CAY1BkB,SAAS,CAfP,QAeO,CAZiB,CAAxB,CAHA,CAiBJtB,YAAY,CApBlBc,QAGU,CAAD,CAFJ,CADc,CAAnBA,CAwBAH,KAAK,CAALA,iBAAAA,CAAAA,SAAAA,EACAG,UAAU,CAAVA,UAAAA,CAAAA,KAAAA,EA7BJF,CAAY,CAAZA,CAlBc,CAAA,CAmDhBW,QAAQ,CAAE,mBAAM,CACdf,iBAAiB,EAAIA,iBAAiB,CAAC,CAAEC,QAAQ,CAAEN,MAAZ,CAAD,CAAtCK,CACAA,iBAAiB,CAAjBA,IAAAA,CACAG,KAAK,CAALA,aAAAA,EAAuBG,UAAU,CAAVA,aAAAA,CAAvBH,KAAuBG,CAAvBH,CAtDc,CAAA,CAwDhBa,IAAI,CAAE,eAAM,CACV,GAAA,MAAA,CAAY,CACVd,OAAO,CAAPA,IAAAA,CAAAA,mEAAAA,EAGA,OACD,CACD,GAAI,CAAJ,SAAA,CAAgB,CACdA,OAAO,CAAPA,IAAAA,CAAAA,iEAAAA,EAGA,OACD,CACDN,UAAU,CAAVA,IAAAA,CACAQ,YAAY,CAACC,GAAG,CAACb,YAAY,CAAb,QAAA,CAAJ,CAAI,CAAJ,CAAgCA,YAAY,CAAxDY,QAAY,CAAZA,CAtEc,CAAA,CAwEhBa,0BAA0B,CAAEC,oCAAAA,MAAM,CAAI,CACpCrB,SAAS,CAATA,IAAAA,GACAF,MAAM,CAANA,MAAAA,CACAQ,KAAK,CAALA,iBAAAA,CAAAA,SAAAA,EACD,CA5Ee,CAAlB,CA8EA,MAAA,CAAA,SAAA,CACD,CAMD,cAAe,SAAA,CAAA,8BAAA,CAAA,IAAA,CAAA,sBAAA,CAGb,CACA,MAAO,UAAA,KAAA,CAAA,KAAA,CAAA,MAAA,CAA0B,CAC/B,GAAIgB,MAAM,GAAV,SAAA,CAA0B,CACxB,MAAOP,CAAAA,IAAI,CAAA,KAAA,CAAA,KAAA,CAAX,MAAW,CAAX,CACD,CACD,MAAOQ,CAAAA,wBAAwB,CAAA,IAAA,CAAA,sBAAA,CAAA,KAAA,CAA/B,KAA+B,CAA/B,CAJF,CAAA,CAMD","sourcesContent":["import {\n  always,\n  block,\n  call,\n  clockRunning,\n  cond,\n  set,\n  startClock,\n  stopClock,\n} from '../base';\nimport Clock from '../core/AnimatedClock';\nimport { evaluateOnce } from '../derived/evaluateOnce';\n\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\n  const newClock = new Clock();\n  const currentState = animationStateDefaults();\n  let alwaysNode;\n  let isStarted = false;\n  let isDone = false;\n  let wasStopped = false;\n  let animationCallback;\n  const animation = {\n    start: currentAnimationCallback => {\n      animationCallback = currentAnimationCallback;\n      if (isStarted) {\n        animationCallback && animationCallback({ finished: false });\n        return;\n      }\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        // inconsistent with React Native\n        return;\n      }\n\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n\n      isStarted = true;\n      evaluateOnce(\n        set(currentState.position, value),\n        currentState.position,\n        () => {\n          alwaysNode = always(\n            set(\n              value,\n              block([\n                cond(clockRunning(newClock), 0, startClock(newClock)),\n                node(newClock, currentState, config),\n                cond(currentState.finished, [\n                  call([], () => {\n                    isStarted = false;\n                    if (!wasStopped) {\n                      isDone = true;\n                    }\n                    value.__detachAnimation(animation);\n                    isDone = true;\n                    if (!wasStopped) {\n                      wasStopped = false;\n                    }\n                  }),\n                  stopClock(newClock),\n                ]),\n                currentState.position,\n              ])\n            )\n          );\n          value.__attachAnimation(animation);\n          alwaysNode.__addChild(value);\n        }\n      );\n    },\n    __detach: () => {\n      animationCallback && animationCallback({ finished: isDone });\n      animationCallback = null;\n      value.__initialized && alwaysNode.__removeChild(value);\n    },\n    stop: () => {\n      if (isDone) {\n        console.warn(\n          'Calling stop has no effect as the animation has already completed'\n        );\n        return;\n      }\n      if (!isStarted) {\n        console.warn(\n          \"Calling stop has no effect as the animation hasn't been started\"\n        );\n        return;\n      }\n      wasStopped = true;\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: result => {\n      animation.stop();\n      isDone = result;\n      value.__detachAnimation(animation);\n    },\n  };\n  return animation;\n}\n\n/**\n * Depending on the arguments list we either return animation node or return an\n * animation object that is compatible with the original Animated API\n */\nexport default function backwardsCompatibleAnimWrapper(\n  node,\n  animationStateDefaults\n) {\n  return (clock, state, config) => {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\n  };\n}\n"]},"metadata":{},"sourceType":"module"}